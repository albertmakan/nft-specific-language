from dataclasses import dataclass
from datetime import datetime
import json
from typing import Dict, List, Set
import re

from spl.model import Script, AddressSet, Percentage, Address
from .constants import *

package_cache = {}


def generate(model: Script, output_file: str):
    dependencies: Set[Dependency] = set()
    manager = model.administration.main_administrator
    contracts = {
        c.name: Contract(
            name=c.name,
            functions={
                **{
                    f.name: Function(
                        name=f.name,
                        params={p.name: format_param(p.literal)
                                for p in f.params.parameters},
                        mod=set()
                    ) for f in c.implementation.methods
                },
                **{
                    admin.method.name: Function(
                        name=admin.method.name,
                        params={p.name: format_param(p.literal)
                                for p in admin.method.params.parameters},
                        is_modifier=True,
                        mod=set()
                    ) for admin in model.administration.extension_administrators
                },
                manager.method.name: Function(
                    name=manager.method.name,
                    params={p.name: format_param(p.literal)
                            for p in manager.method.params.parameters},
                    is_modifier=True,
                    mod=set()
                )
            },
            dependencies=set(),
        ).resolve_code_and_dependencies(dependencies)
        .insert_params() for c in model.contract_section.contracts
    }

    for ca in manager.contract_administrators:
        for method in ca.methods:
            contracts[ca.contract.name].functions[method.name].mod.add(
                manager.method.name)

    for admin in model.administration.extension_administrators:
        for ca in admin.contract_administrators:
            for method in ca.methods:
                contracts[ca.contract.name].functions[method.name].mod.add(
                    admin.method.name)

    for contract in contracts.values():
        for fun in contract.functions.values():
            fun.insert_modifiers()

    with open(output_file, 'w') as f:
        f.write(f"/* Generated by SPL [{datetime.now()}] */\n\n")
        f.write("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n")
        f.write("//"+" DEPENDENCIES ".center(100, '=')+'\n\n')
        for d in sorted(list(dependencies), key=lambda d: (d.type, d.priority), reverse=True):
            f.write(d.code+'\n')
        f.write("//"+" YOUR CONTRACTS ".center(100, '=')+'\n\n')
        for c in contracts.values():
            f.write(f"contract {c.name} " + "{\n")
            for d in sorted(list(c.dependencies), key=lambda d: d.type, reverse=True):
                f.write('\t'+d.code+'\n')
            for m in c.functions.values():
                f.write('\t'+m.code+'\n')
            f.write("\n}\n")


@dataclass
class Dependency:
    name: str
    code: str
    type: str
    priority: int = 0

    def __eq__(self, other):
        if not isinstance(other, Dependency):
            return False
        return self.name == other.name and self.code == other.code and self.type == other.type

    def __hash__(self):
        return hash((self.name, self.code, self.type))


@dataclass
class Function:
    params: Dict[str, str]
    name: str
    mod: Set[str]
    code: str = ""
    is_modifier: bool = False

    def insert_params(self):
        for par in self.params:
            matches: List[str] = re.findall(
                fr'{{{{\s*{par}\s*:\s*\w+\s*}}}}', self.code)
            if not matches:
                continue
            par_type = matches[0][2:-2].split(':')[1].strip()
            self.code = self.code.replace(matches[0], self.params[par])
        left: List[str] = re.findall(
            fr'{{{{\s*\w+\s*:\s*\w+\s*}}}}', self.code)
        if left:
            raise Exception("Missing params:", left)
        return self

    def insert_modifiers(self):
        to_insert = " ".join((m.split('.')[-1] for m in self.mod))
        block_start = self.code.find('{')
        returns_loc = self.code.find('returns', 0, block_start)
        idx = returns_loc if returns_loc != -1 else block_start
        self.code = self.code[:idx] + to_insert + self.code[idx-1:]
        return self


@dataclass
class Contract:
    functions: Dict[str, Function]
    dependencies: Set[Dependency]
    name: str

    def resolve_code_and_dependencies(self, globals: Set[Dependency]):
        for fun in self.functions.values():
            try:
                self._resolve(fun, globals)
            except KeyError:
                raise Exception(
                    f"{'Modifier' if fun.is_modifier else 'Function'} '{fun.name}' not found")
        return self

    def insert_params(self):
        for fun in self.functions.values():
            fun.insert_params()
        return self

    def _resolve(self, fun: Function, globals: Set[Dependency]):
        pack_name, *path, func_name = fun.name.split('.')

        if not pack_name in package_cache:
            with open(f'{SPM_PACKAGES_PATH}/{pack_name}.json') as pack:
                package_cache[pack_name] = json.load(pack)
        package = package_cache[pack_name]

        current_block, parent_block = package, None
        for key in path:
            parent_block = current_block
            current_block = current_block[key]
        result = current_block[MODIFIERS if fun.is_modifier else FUNCTIONS][func_name]
        fun.code = result[CODE]

        def find_dep(thing: dict):
            if DEPENDENCIES not in thing:
                return
            dependencies: Dict[str, List[str]] = thing[DEPENDENCIES]
            for dep_type in dependencies:
                for name in dependencies[dep_type]:
                    if dep_type == CONTRACTS:
                        c = parent_block[name]
                        globals.add(Dependency(name, c[CODE], dep_type))
                        find_contract_dependencies(parent_block, name, globals)
                        continue

                    dep = current_block[dep_type].get(name, None)
                    if dep:
                        self.dependencies.add(Dependency(name, dep[CODE], dep_type))
                        find_dep(dep)
                        continue
                    base = current_block[BASE]
                    if base:
                        dep = parent_block[base][dep_type].get(name, None)
                        if dep:
                            self.dependencies.add(Dependency(name, dep[CODE], dep_type))
                            find_dep(dep)
                            continue
                    dep = parent_block[GLOBAL][dep_type].get(name, None)
                    globals.add(Dependency(name, dep[CODE], dep_type))
                    find_dep(dep)

        find_dep(result)


def format_param(param):
    if isinstance(param, Address):
        return f"address({param.value})"
    if isinstance(param, AddressSet):
        return f'[{", ".join((f"address({a.value})" for a in param.values))}]'
    if isinstance(param, Percentage):
        return str(param.percent)
    if isinstance(param, str):
        param = param.replace('"', "'")
        return f'{"" if param.isascii() else "unicode"}"{param}"'
    return str(param)


def find_contract_dependencies(_package: dict, c_name: str, globals: Set[Dependency], p=0):
    contract = _package[c_name]
    p += 1
    base_name = contract[BASE]
    if base_name:
        globals.add(Dependency(base_name, _package[base_name][CODE], CONTRACTS, p))
        find_contract_dependencies(_package, base_name, globals, p)
    for thing_type in contract:
        if thing_type == CODE or thing_type == BASE:
            continue
        things = contract[thing_type]
        for thing_name in things:
            thing = things[thing_name]
            if DEPENDENCIES not in thing:
                continue
            dependencies: Dict[str, List[str]] = thing[DEPENDENCIES]
            for dep_type in dependencies:
                for name in dependencies[dep_type]:
                    if dep_type == CONTRACTS:
                        c = _package[name]
                        globals.add(Dependency(name, c[CODE], dep_type, p))
                        find_contract_dependencies(_package, name, globals, p)
                        continue
                    if name in contract[dep_type] or (base_name and name in _package[base_name][dep_type]):
                        continue
                    dep = _package[GLOBAL][dep_type].get(name, None)
                    globals.add(Dependency(name, dep[CODE], dep_type, p))


# TODO:
# handle name conflict
# contract dependencies
# insert modifiers params?
# param type check?
# package path fix after merge
# difference between managed and extended?
